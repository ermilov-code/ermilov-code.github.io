// ================ js/main-gallery.js ================

/* 2. *Добавить в галерею функцию перехода к следующему изображению. По сторонам от большой картинки должны быть стрелки «вперед» и «назад», по нажатию на которые происходит замена изображения на следующее или предыдущее. */

// у меня есть ссылки на изображения
let IMGS = [
    './img/photo-for-gallery-1.jpg',
    './img/photo-for-gallery-2.jpg',
    './img/photo-for-gallery-3.jpg',
    './img/photo-for-gallery-4.jpg'
]

// будем делать по тому же принципу, по которму мы создаем товары
// берем главное изображение
let MAIN_PIC = document.querySelector('#MAIN-PIC')
let roulette = document.querySelector('#roulette')
// добавим control к слушателям событий - теперь мы будем прослушивать наш control 
let control = document.querySelector('#control')


// когда 
window.onload = () => {
    MAIN_PIC.src = IMGS[0]
    // мы будем обходить наш массив forEach-ем 
    // в рулетку (можно innert html - но заюзаем новый способ) 
    // insertAdjacentHTML - это такой метод, который работает с двумя параметрами - первый (указываете местоположение - куда) - а вторым параметром вы указываtnt (ЧТО!)
    // то есть мы вызываем функцию createItem(img), пробрасываем туда IMG - и на выходе у объекта, который отсюда выйдет - мы вызываем createTemplate() - которая нам возвращает HTML строку - который он beforeend вставит 
    // такой метод нужно использовать, если вы не хотите заморачиваться 
    IMGS.forEach(img => {
        roulette.insertAdjacentHTML('beforeend', createItem(img).createTemplate())
    })
}

// создадим функцию, которая будет возвращать объект 
// привыкаем к использованию объектов

function createItem(url) {
    return {
        // можно задавать параметры
        // ширину пока убрал! 
        // width: 150,
        height: 120,
        // метод, который возвращает нам строчку
        // очень здорово для изображений иметь такую практику, потому что если у вас изображения большие, а вы хотите их сделать маленькими, (а у вас в стилях написано все - но изображение может загрузится быстрее чем стили) - 
        createTemplate() {
            return `
                <img src="${url}" class="gallery-img" width="${this.width}" height="${this.height}"></img>
            `
        }
    }
}

// мы на нашу рулетку вешаем (помня о том, что мы не будем на каждую картинку вешать событие клик) - мы повесим его на всю рулетку 
roulette.addEventListener('click', evt => {
    // если я буду кликать по элементу, который является картинкой - 
    if (evt.target.tagName === 'IMG') {
        // мы у главной картинки будем присваивать источник evt таргета 
        MAIN_PIC.src = evt.target.src
    }
})


// навешиваем на него
control.addEventListener('click', (evt) => {
    // стрелочная функция 
    let btn = evt.target

    // ДРУЗЬЯ - используйте name - ы, кто не использует! 
    // name - ом мы можем идентифицировать любой элемент нашего фронта - мы можем один и тотже name накидывать на кучу разных элементов
    if (btn.name === 'control') {
        // с классом тоже можно было - вот так:
        // if (btn.classList.contains ('control')) {} - больше писанины
        let delta = +btn.dataset.step /* это изменение - оно может быть либо +1 либо -1*/
        // находим, какое у нас изображение было главным
        let actual = IMGS.indexOf(MAIN_PIC.src)

        // дальше делаем два условия 
        // если актуальное изображение = длине массива изображений -1
        if ((actual === IMGS.length - 1) && (delta === 1)) actual = -1
        if ((actual === 0) && (delta === -1)) actual = IMGS.length

        MAIN_PIC.src = IMGS[actual + delta]
    }
})

// ================ js/main-gallery.js ================